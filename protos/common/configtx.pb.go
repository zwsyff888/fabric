// Code generated by protoc-gen-go.
// source: common/configtx.proto
// DO NOT EDIT!

package common

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ConfigItem_ConfigType int32

const (
	ConfigItem_POLICY  ConfigItem_ConfigType = 0
	ConfigItem_CHAIN   ConfigItem_ConfigType = 1
	ConfigItem_ORDERER ConfigItem_ConfigType = 2
	ConfigItem_PEER    ConfigItem_ConfigType = 3
	ConfigItem_MSP     ConfigItem_ConfigType = 4
)

var ConfigItem_ConfigType_name = map[int32]string{
	0: "POLICY",
	1: "CHAIN",
	2: "ORDERER",
	3: "PEER",
	4: "MSP",
}
var ConfigItem_ConfigType_value = map[string]int32{
	"POLICY":  0,
	"CHAIN":   1,
	"ORDERER": 2,
	"PEER":    3,
	"MSP":     4,
}

func (x ConfigItem_ConfigType) String() string {
	return proto.EnumName(ConfigItem_ConfigType_name, int32(x))
}
func (ConfigItem_ConfigType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{10, 0} }

// ConfigEnvelope is designed to contain _all_ configuration for a chain with no dependency
// on previous configuration transactions.
//
// It is generated with the following scheme:
//   1. Retrieve the existing configuration
//   2. Note the highest configuration sequence number, store it and increment it by one
//   3. Modify desired ConfigItems, setting each LastModified to the stored and incremented sequence number
//     a) Note that the ConfigItem has a ChannelHeader header attached to it, who's type is set to CONFIGURATION_ITEM
//   4. Create Config message containing the new configuration, marshal it into ConfigEnvelope.config and encode the required signatures
//     a) Each signature is of type ConfigSignature
//     b) The ConfigSignature signature is over the concatenation of signatureHeader and the Config bytes (which includes a ChannelHeader)
//   5. Submit new Config for ordering in Envelope signed by submitter
//     a) The Envelope Payload has data set to the marshaled ConfigEnvelope
//     b) The Envelope Payload has a header of type Header.Type.CONFIGURATION_TRANSACTION
//
// The configuration manager will verify:
//   1. All configuration items and the envelope refer to the correct chain
//   2. Some configuration item has been added or modified
//   3. No existing configuration item has been ommitted
//   4. All configuration changes have a LastModification of one more than the last configuration's highest LastModification number
//   5. All configuration changes satisfy the corresponding modification policy
type ConfigEnvelope struct {
	Config     []byte             `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	Signatures []*ConfigSignature `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty"`
}

func (m *ConfigEnvelope) Reset()                    { *m = ConfigEnvelope{} }
func (m *ConfigEnvelope) String() string            { return proto.CompactTextString(m) }
func (*ConfigEnvelope) ProtoMessage()               {}
func (*ConfigEnvelope) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *ConfigEnvelope) GetSignatures() []*ConfigSignature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// ConfigTemplate is used as a serialization format to share configuration templates
// The orderer supplies a configuration template to the user to use when constructing a new
// chain creation transaction, so this is used to facilitate that.
type ConfigTemplate struct {
	Items []*ConfigItem `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *ConfigTemplate) Reset()                    { *m = ConfigTemplate{} }
func (m *ConfigTemplate) String() string            { return proto.CompactTextString(m) }
func (*ConfigTemplate) ProtoMessage()               {}
func (*ConfigTemplate) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *ConfigTemplate) GetItems() []*ConfigItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type ConfigGroupSchema struct {
	Groups   map[string]*ConfigGroupSchema  `protobuf:"bytes,1,rep,name=groups" json:"groups,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Values   map[string]*ConfigValueSchema  `protobuf:"bytes,2,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Policies map[string]*ConfigPolicySchema `protobuf:"bytes,3,rep,name=policies" json:"policies,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ConfigGroupSchema) Reset()                    { *m = ConfigGroupSchema{} }
func (m *ConfigGroupSchema) String() string            { return proto.CompactTextString(m) }
func (*ConfigGroupSchema) ProtoMessage()               {}
func (*ConfigGroupSchema) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *ConfigGroupSchema) GetGroups() map[string]*ConfigGroupSchema {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ConfigGroupSchema) GetValues() map[string]*ConfigValueSchema {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *ConfigGroupSchema) GetPolicies() map[string]*ConfigPolicySchema {
	if m != nil {
		return m.Policies
	}
	return nil
}

type ConfigValueSchema struct {
}

func (m *ConfigValueSchema) Reset()                    { *m = ConfigValueSchema{} }
func (m *ConfigValueSchema) String() string            { return proto.CompactTextString(m) }
func (*ConfigValueSchema) ProtoMessage()               {}
func (*ConfigValueSchema) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

type ConfigPolicySchema struct {
}

func (m *ConfigPolicySchema) Reset()                    { *m = ConfigPolicySchema{} }
func (m *ConfigPolicySchema) String() string            { return proto.CompactTextString(m) }
func (*ConfigPolicySchema) ProtoMessage()               {}
func (*ConfigPolicySchema) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

// This message may change slightly depending on the finalization of signature schemes for transactions
type Config struct {
	Header *ChannelHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Items  []*ConfigItem  `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *Config) GetHeader() *ChannelHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Config) GetItems() []*ConfigItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// XXX this structure is to allow us to minimize the diffs in this change series
// it will be renamed Config once the original is ready to be removed
type ConfigNext struct {
	Header  *ChannelHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Channel *ConfigGroup   `protobuf:"bytes,2,opt,name=channel" json:"channel,omitempty"`
}

func (m *ConfigNext) Reset()                    { *m = ConfigNext{} }
func (m *ConfigNext) String() string            { return proto.CompactTextString(m) }
func (*ConfigNext) ProtoMessage()               {}
func (*ConfigNext) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *ConfigNext) GetHeader() *ChannelHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ConfigNext) GetChannel() *ConfigGroup {
	if m != nil {
		return m.Channel
	}
	return nil
}

// ConfigGroup is the hierarchical data structure for holding config
type ConfigGroup struct {
	Version   uint64                   `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	Groups    map[string]*ConfigGroup  `protobuf:"bytes,2,rep,name=groups" json:"groups,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Values    map[string]*ConfigValue  `protobuf:"bytes,3,rep,name=values" json:"values,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Policies  map[string]*ConfigPolicy `protobuf:"bytes,4,rep,name=policies" json:"policies,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ModPolicy string                   `protobuf:"bytes,5,opt,name=mod_policy,json=modPolicy" json:"mod_policy,omitempty"`
}

func (m *ConfigGroup) Reset()                    { *m = ConfigGroup{} }
func (m *ConfigGroup) String() string            { return proto.CompactTextString(m) }
func (*ConfigGroup) ProtoMessage()               {}
func (*ConfigGroup) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *ConfigGroup) GetGroups() map[string]*ConfigGroup {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ConfigGroup) GetValues() map[string]*ConfigValue {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *ConfigGroup) GetPolicies() map[string]*ConfigPolicy {
	if m != nil {
		return m.Policies
	}
	return nil
}

// ConfigValue represents an individual piece of config data
type ConfigValue struct {
	Version   uint64 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	Value     []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	ModPolicy string `protobuf:"bytes,3,opt,name=mod_policy,json=modPolicy" json:"mod_policy,omitempty"`
}

func (m *ConfigValue) Reset()                    { *m = ConfigValue{} }
func (m *ConfigValue) String() string            { return proto.CompactTextString(m) }
func (*ConfigValue) ProtoMessage()               {}
func (*ConfigValue) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

type ConfigPolicy struct {
	Version   uint64  `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	Policy    *Policy `protobuf:"bytes,2,opt,name=policy" json:"policy,omitempty"`
	ModPolicy string  `protobuf:"bytes,3,opt,name=mod_policy,json=modPolicy" json:"mod_policy,omitempty"`
}

func (m *ConfigPolicy) Reset()                    { *m = ConfigPolicy{} }
func (m *ConfigPolicy) String() string            { return proto.CompactTextString(m) }
func (*ConfigPolicy) ProtoMessage()               {}
func (*ConfigPolicy) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *ConfigPolicy) GetPolicy() *Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

type ConfigItem struct {
	Type               ConfigItem_ConfigType `protobuf:"varint,1,opt,name=type,enum=common.ConfigItem_ConfigType" json:"type,omitempty"`
	LastModified       uint64                `protobuf:"varint,2,opt,name=last_modified,json=lastModified" json:"last_modified,omitempty"`
	ModificationPolicy string                `protobuf:"bytes,3,opt,name=modification_policy,json=modificationPolicy" json:"modification_policy,omitempty"`
	Key                string                `protobuf:"bytes,4,opt,name=key" json:"key,omitempty"`
	Value              []byte                `protobuf:"bytes,5,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ConfigItem) Reset()                    { *m = ConfigItem{} }
func (m *ConfigItem) String() string            { return proto.CompactTextString(m) }
func (*ConfigItem) ProtoMessage()               {}
func (*ConfigItem) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

type ConfigSignature struct {
	SignatureHeader []byte `protobuf:"bytes,1,opt,name=signature_header,json=signatureHeader,proto3" json:"signature_header,omitempty"`
	Signature       []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *ConfigSignature) Reset()                    { *m = ConfigSignature{} }
func (m *ConfigSignature) String() string            { return proto.CompactTextString(m) }
func (*ConfigSignature) ProtoMessage()               {}
func (*ConfigSignature) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func init() {
	proto.RegisterType((*ConfigEnvelope)(nil), "common.ConfigEnvelope")
	proto.RegisterType((*ConfigTemplate)(nil), "common.ConfigTemplate")
	proto.RegisterType((*ConfigGroupSchema)(nil), "common.ConfigGroupSchema")
	proto.RegisterType((*ConfigValueSchema)(nil), "common.ConfigValueSchema")
	proto.RegisterType((*ConfigPolicySchema)(nil), "common.ConfigPolicySchema")
	proto.RegisterType((*Config)(nil), "common.Config")
	proto.RegisterType((*ConfigNext)(nil), "common.ConfigNext")
	proto.RegisterType((*ConfigGroup)(nil), "common.ConfigGroup")
	proto.RegisterType((*ConfigValue)(nil), "common.ConfigValue")
	proto.RegisterType((*ConfigPolicy)(nil), "common.ConfigPolicy")
	proto.RegisterType((*ConfigItem)(nil), "common.ConfigItem")
	proto.RegisterType((*ConfigSignature)(nil), "common.ConfigSignature")
	proto.RegisterEnum("common.ConfigItem_ConfigType", ConfigItem_ConfigType_name, ConfigItem_ConfigType_value)
}

func init() { proto.RegisterFile("common/configtx.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 738 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x55, 0x51, 0x4f, 0xd3, 0x50,
	0x14, 0x76, 0xeb, 0xd6, 0xb1, 0xb3, 0x01, 0xf3, 0x0e, 0x74, 0x2e, 0x12, 0xb1, 0x46, 0x1d, 0x1a,
	0x98, 0xce, 0x07, 0x0c, 0x09, 0x0f, 0x3a, 0x17, 0x21, 0x91, 0x31, 0x2f, 0x44, 0x23, 0x31, 0x21,
	0xa5, 0xbb, 0x6c, 0xd5, 0xb6, 0xb7, 0x69, 0x3b, 0x42, 0x5f, 0xfd, 0x9b, 0xfe, 0x03, 0x7f, 0x85,
	0xe9, 0xbd, 0xb7, 0xe5, 0x96, 0x75, 0x5b, 0x78, 0x5a, 0xef, 0x39, 0xe7, 0xfb, 0xbe, 0xd3, 0x73,
	0xbe, 0xee, 0xc2, 0xba, 0x41, 0x6d, 0x9b, 0x3a, 0x6d, 0x83, 0x3a, 0x97, 0xe6, 0x28, 0xb8, 0xde,
	0x71, 0x3d, 0x1a, 0x50, 0xa4, 0xf2, 0x70, 0xb3, 0x9e, 0xa4, 0xa3, 0x1f, 0x9e, 0x6c, 0xc6, 0x18,
	0x97, 0x5a, 0xa6, 0x61, 0x12, 0x9f, 0x87, 0x35, 0x1d, 0x56, 0xba, 0x8c, 0xa5, 0xe7, 0x5c, 0x11,
	0x8b, 0xba, 0x04, 0x3d, 0x00, 0x95, 0xf3, 0x36, 0x72, 0x9b, 0xb9, 0x56, 0x15, 0x8b, 0x13, 0xda,
	0x05, 0xf0, 0xcd, 0x91, 0xa3, 0x07, 0x13, 0x8f, 0xf8, 0x8d, 0xfc, 0xa6, 0xd2, 0xaa, 0x74, 0x1e,
	0xee, 0x08, 0x0d, 0xce, 0x71, 0x12, 0xe7, 0xb1, 0x54, 0xaa, 0xed, 0xc5, 0x12, 0xa7, 0xc4, 0x76,
	0x2d, 0x3d, 0x20, 0xa8, 0x05, 0x45, 0x33, 0x20, 0xb6, 0xdf, 0xc8, 0x31, 0x16, 0x94, 0x66, 0x39,
	0x0c, 0x88, 0x8d, 0x79, 0x81, 0xf6, 0x57, 0x81, 0xfb, 0x3c, 0xfa, 0xd9, 0xa3, 0x13, 0xf7, 0xc4,
	0x18, 0x13, 0x5b, 0x47, 0xfb, 0xa0, 0x8e, 0xa2, 0x63, 0x4c, 0xf0, 0x3c, 0x4d, 0x20, 0x95, 0xee,
	0xb0, 0x67, 0xbf, 0xe7, 0x04, 0x5e, 0x88, 0x05, 0x28, 0x82, 0x5f, 0xe9, 0xd6, 0x24, 0x79, 0x8b,
	0x39, 0xf0, 0x6f, 0xac, 0x4e, 0xc0, 0x39, 0x08, 0x75, 0x61, 0x29, 0x1e, 0x62, 0x43, 0x61, 0x04,
	0x2f, 0x67, 0x13, 0x0c, 0x44, 0x25, 0xa7, 0x48, 0x80, 0xcd, 0x53, 0xa8, 0x48, 0xad, 0xa1, 0x1a,
	0x28, 0xbf, 0x49, 0xc8, 0x26, 0x5e, 0xc6, 0xd1, 0x23, 0x6a, 0x43, 0x91, 0xe9, 0x35, 0xf2, 0x9b,
	0xb9, 0x56, 0xa5, 0xf3, 0x68, 0xa6, 0x04, 0xe6, 0x75, 0x7b, 0xf9, 0xf7, 0xb9, 0x88, 0x55, 0xea,
	0xf8, 0xce, 0xac, 0x0c, 0x3b, 0xcd, 0xfa, 0x1d, 0x96, 0x53, 0xaf, 0x91, 0xc1, 0xfb, 0x26, 0xcd,
	0xdb, 0x4c, 0xf3, 0x32, 0x74, 0x38, 0x45, 0xac, 0xd5, 0xe3, 0xe5, 0x4a, 0xc2, 0xda, 0x1a, 0xa0,
	0x69, 0x94, 0xa6, 0x83, 0xca, 0xa3, 0x68, 0x1b, 0xd4, 0x31, 0xd1, 0x87, 0xc4, 0x63, 0xfa, 0x95,
	0xce, 0x7a, 0xa2, 0x35, 0xd6, 0x1d, 0x87, 0x58, 0x07, 0x2c, 0x89, 0x45, 0xd1, 0x8d, 0xd7, 0xf2,
	0x8b, 0xbc, 0xf6, 0x0b, 0x80, 0x07, 0xfb, 0xe4, 0x3a, 0xb8, 0xab, 0xcc, 0x36, 0x94, 0x0c, 0x9e,
	0x10, 0x23, 0xa8, 0x67, 0x2c, 0x0c, 0xc7, 0x35, 0xda, 0x3f, 0x05, 0x2a, 0x52, 0x02, 0x35, 0xa0,
	0x74, 0x45, 0x3c, 0xdf, 0xa4, 0x0e, 0x93, 0x2b, 0xe0, 0xf8, 0x88, 0x76, 0x13, 0xaf, 0xf3, 0x17,
	0x78, 0x92, 0xc1, 0x9b, 0xe9, 0xf2, 0xdd, 0xc4, 0xe5, 0xca, 0x6c, 0x60, 0x96, 0xbf, 0xf7, 0x25,
	0x7f, 0x17, 0x18, 0xf4, 0x69, 0x16, 0x74, 0x86, 0xb3, 0xd1, 0x06, 0x80, 0x4d, 0x87, 0xe7, 0xec,
	0x1c, 0x36, 0x8a, 0xcc, 0x23, 0x65, 0x9b, 0x0e, 0xf9, 0x3a, 0x9b, 0xfd, 0x45, 0xc6, 0xdf, 0x4a,
	0x5b, 0x29, 0x73, 0x8e, 0x92, 0x39, 0xfb, 0x8b, 0x2c, 0x3f, 0x9f, 0x8f, 0x61, 0x65, 0xbe, 0xaf,
	0x8b, 0xcd, 0xfe, 0x2a, 0xcd, 0xb8, 0x96, 0x65, 0x76, 0xd9, 0xe6, 0x3f, 0xe3, 0x5d, 0x33, 0xb1,
	0x39, 0xbb, 0x5e, 0x93, 0x89, 0xab, 0x82, 0xe2, 0xd6, 0x40, 0x95, 0x5b, 0x03, 0xd5, 0x28, 0x54,
	0x65, 0xe1, 0x39, 0xf4, 0x2f, 0x40, 0x15, 0x24, 0xbc, 0xf1, 0x95, 0xb8, 0x71, 0xd1, 0xb2, 0xc8,
	0x2e, 0x12, 0xfc, 0x93, 0x8f, 0x3f, 0x94, 0xe8, 0xeb, 0x41, 0x6f, 0xa1, 0x10, 0x84, 0x2e, 0x61,
	0x62, 0x2b, 0x9d, 0x8d, 0xe9, 0xef, 0x4b, 0x3c, 0x9e, 0x86, 0x2e, 0xc1, 0xac, 0x14, 0x3d, 0x83,
	0x65, 0x4b, 0xf7, 0x83, 0x73, 0x9b, 0x0e, 0xcd, 0x4b, 0x93, 0x0c, 0x59, 0x3f, 0x05, 0x5c, 0x8d,
	0x82, 0x47, 0x22, 0x86, 0xda, 0x50, 0xe7, 0x79, 0x43, 0x0f, 0x4c, 0xea, 0xa4, 0xdb, 0x41, 0x72,
	0x4a, 0xbc, 0xb8, 0x58, 0x54, 0xe1, 0x66, 0x51, 0xc9, 0x3c, 0x8b, 0xd2, 0x3c, 0xb5, 0x6e, 0xdc,
	0x7e, 0xd4, 0x11, 0x02, 0x50, 0x07, 0xc7, 0x5f, 0x0e, 0xbb, 0x3f, 0x6a, 0xf7, 0x50, 0x19, 0x8a,
	0xdd, 0x83, 0x0f, 0x87, 0xfd, 0x5a, 0x0e, 0x55, 0xa0, 0x74, 0x8c, 0x3f, 0xf5, 0x70, 0x0f, 0xd7,
	0xf2, 0x68, 0x09, 0x0a, 0x83, 0x5e, 0x0f, 0xd7, 0x14, 0x54, 0x02, 0xe5, 0xe8, 0x64, 0x50, 0x2b,
	0x68, 0x67, 0xb0, 0x7a, 0xeb, 0xce, 0x43, 0x5b, 0x50, 0x4b, 0x6e, 0xbd, 0x73, 0xe9, 0xbf, 0xa3,
	0x8a, 0x57, 0x93, 0x38, 0xff, 0xd7, 0x40, 0x8f, 0xa1, 0x9c, 0x84, 0xc4, 0xb2, 0x6f, 0x02, 0x1f,
	0xb7, 0xcf, 0x5e, 0x8f, 0xcc, 0x60, 0x3c, 0xb9, 0x88, 0x66, 0xd9, 0x1e, 0x87, 0x2e, 0xf1, 0x2c,
	0x32, 0x1c, 0x11, 0xaf, 0x7d, 0xa9, 0x5f, 0x78, 0xa6, 0xd1, 0x66, 0x57, 0xb7, 0x2f, 0xee, 0xf7,
	0x0b, 0x95, 0x1d, 0xdf, 0xfd, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xd7, 0x09, 0xc0, 0xa2, 0x16, 0x08,
	0x00, 0x00,
}
